
在这里，我们将了解和学习Ruby中的对象和类。 在面向对象编程语言中，使用对象和类设计程序。
对象是物理和逻辑实体，而类只是一个逻辑实体。

# 1 Ruby对象

`Object`类是所有Ruby对象的默认根。 Ruby对象继承自`BasicObject`(它是Ruby中所有类的父类)类，允许创建替代对象层次结构。
对象混合在内核模块中，使得内置的内核功能可以全局访问。

## 1.1 创建对象

Ruby中的对象是通过调用类的`new`方法来创建的。 它是一种独特的方法，并在Ruby库中预定义。

Ruby对象是类的实例。

**语法**

```ruby
objectName = className.new
```

**示例：**

假设我们有一个名为`Stuent`的类。 现在，创建一个对象`stu`，并使用以下命令，

```ruby
stu = Studen.new("John")
```

完整示例代码 -

```ruby
class Student
  attr_accessor :name, :phone
  def introduction()
    puts "Hi , I'm #{name}!"
  end

def say_hello(name, toname)
  puts "Hello, #{toname}! I'm #{name}"
  end

end

stu = Student.new
stu.name = "Maxsu"
stu.introduction()
stu.say_hello('Katrina', 'Maxsu')
```

将上面代码保存到文件：_student.rb_，执行上面代码，得到以下结果 -

```shell
F:\worksp\ruby>ruby Student.rb
Hi , I'm Maxsu!
Hello, Maxsu! I'm Katrina

F:\worksp\ruby>
```

# 2 Ruby类

每个Ruby类都是`Class`类的一个实例。 Ruby中的类是一流的对象。

Ruby类始终以`class`关键字后接类名开头。 通常对于类名，使用驼峰命名规则(`CamelCase`)。 类的名称应始终以大写字母开头。定义类是用`end`关键字完成的。

**语法**

```ruby
class ClassName  
    codes...  
end
```

如下示例代码中，定义一个名称为：`Dog` 的类 -

```ruby
class Dog  
  def initialize(breed, name)  
    # Instance variables  
    @breed = breed  
    @name = name  
  end  

  def bark  
    puts 'Ruff! Ruff!'  
  end  

  def display  
    puts "I am of #{@breed} breed and my name is #{@name}"  
  end  
end  

# make an object  
# Objects are created on the heap  
d = Dog.new('Labrador', 'Benzy') 
d.bark  
d.display
```

在上面的例子中，我们使用`class`关键字创建了一个`Dog`类。 `d`是一个实例变量，可用于调用`Dog`类的所有方法。



# 3 如何定义一个类

定义一个基本类，`initialize`为构造函数, {@+变量名}相当于类内的全局变量

```ruby
class Player
    #构造函数 @name为模板级变量，定义后可在类中访问。
    def initialize(name = "Koma")
        @name = name
    end
    def show()
        puts "player: #{@name}"
    end
end
```

实例化一个基本类：

```ruby
koma = Player.new()
koma.show()

curry = Player.new("Curry")
curry.show()
```

## 3.1 与类相关的一些基本方法

- `instance_methods(false)`：列出类(class)内部的方法，一般为false，表示仅列举出定义了的方法。即使方法（函数）为空，也会被列举出来。

```ruby
puts Class.instance_methods(false)
```

- `respond_to?`：调查对象(object)的方法/属性是否可用。一般类会对自身的属性或方法作出外部调用的限制，输出true或false。

```ruby
puts "Ist es möglich anzurufen: " + object.respond_to?("title").to_s
```

- `send`：执行对象(object)相应的方法。

```ruby
if object.respond_to?("show") #判断对象是否存在show方法
   object.send("show")       #执行指定的方法
end
```

## 3.2 外部修改object的属性值

类内的属性（Attribute）默认为私密状态。

```ruby
class Game
    attr_accessor :price, :title #可以被外部调用修改
    def initialize(title = "怪物猎人世界", price = 200)
        @title = title
        @price = price
    end
    def show()
        puts "标题: #{@title}"
        puts "价格: #{@price}"
    end
end
mygame = Game.new() #实例化（ instantiate ）

# to_s用于puts输出
puts "title is " + mygame.respond_to?("title").to_s
puts "price is " + mygame.respond_to?("price").to_s
# 由于均被设置为可以获取，故下面语句不会报错。
mygame.title = "Super Mario World"
mygame.price = 150
mygame.show()
```

## 3.3 静态方法——self

self.Methods只能被类本身（class）而不能被实例（object）调用

```ruby
class Game
    def initialize(id, title, price)
        @id = id
        @title = title
        @price = price
    end

    def showGame
        puts @id + ", " + @title + ", " + @price.to_s
    end

    def self.toStr
        puts "I love this game."
    end
end

zelda = Game.new("zelda", "ゼルダの伝説", 350)
zelda.showGame
#zelda.toStr #去掉注释会报错
# 以下两种调用方式均可。
Game.toStr
Game::toStr
```


# 4 Class继承

面向对象的编程必然会涉及到继承的问题。Ruby的继承的基本思路与其他编程语言类似。  
Ruby使用“<”继承：`Subclass < Father_class`

```ruby
#继承上一段代码的类
class SteamGame < Game
    def SteamInfo
        puts "G胖说了,STEAM要统一各个平台，完成Game All In One。"
    end
end
SteamGame.toStr
mygame = SteamGame.new("nobunaga-taishi", "信長の野望・大志", 450)
mygame.showGame
mygame.SteamInfo
```


