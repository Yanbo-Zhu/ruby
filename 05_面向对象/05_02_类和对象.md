
在这里，我们将了解和学习Ruby中的对象和类。 在面向对象编程语言中，使用对象和类设计程序。
对象是物理和逻辑实体，而类只是一个逻辑实体。

# 1 Ruby类

每个Ruby类都是`Class`类的一个实例。 Ruby中的类是一流的对象。

Ruby类始终以`class`关键字后接类名开头。 定义类是用`end`关键字完成的。
通常对于类名，使用驼峰命名规则(`CamelCase`)。 类的名称应始终以大写字母开头。

**语法**

```ruby
class ClassName  
    codes...  
end
```

如下示例代码中，定义一个名称为：`Dog` 的类 -

```ruby
class Dog  
  def initialize(breed, name)  
    # Instance variables  
    @breed = breed  
    @name = name  
  end  

  def bark  
    puts 'Ruff! Ruff!'  
  end  

  def display  
    puts "I am of #{@breed} breed and my name is #{@name}"  
  end  
end  

# make an object  
# Objects are created on the heap  
d = Dog.new('Labrador', 'Benzy') 
d.bark  
d.display
```

在上面的例子中，我们使用`class`关键字创建了一个`Dog`类。 `d`是一个实例变量，可用于调用`Dog`类的所有方法。



```ruby
#!/usr/bin/ruby   
# file : dog.rb

class Dog

  def initialize(name="Wong")
    @name = name
  end

  def say_welcome
    puts "Welcome  #{@name}!"
  end

  def say_bye
    puts "Bye  #{@name}, See you soon."
  end
 end
```

创建一个新类: `Dog` 。 `[@name](https://github.com/name "@name")`是可用于`Dog`类的所有方法的实例变量。它在`say_welcome`和`say_bye`方法中使用。

## 1.1 如何定义一个类

定义一个基本类，`initialize`为构造函数, {@+变量名}相当于类内的全局变量

```ruby
class Player
    #构造函数 @name为模板级变量，定义后可在类中访问。
    def initialize(name = "Koma")
        @name = name
    end
    def show()
        puts "player: #{@name}"
    end
end
```

实例化一个基本类：

```ruby
koma = Player.new()
koma.show()

curry = Player.new("Curry")
curry.show()
```


Ruby的```class```关键字更像是一个**作用域操作符**，而不是类型声明语句

* ```class```的确可创建一个不存在的类（只是副作用）
*  ```class```的核心任务是把我们带到类的上下文中，让我们可以在里面定义方法


## 1.2 构造函数 constructors 

创建对象时自动调用构造函数，并且不返回任何值。 在Ruby中，构造函数叫作：`initialize`。

构造函数的主要目的是启动对象的状态,它们不能被继承。使用`super`方法调用父对象构造函数。

**示例：**

```ruby
#!/usr/bin/ruby   
# file: class-initialize.rb
class Parent   

    def initialize   
        puts "Parent is created"   
    end   

end   

Parent.new
```

执行上面代码，得到以下结果 -

```shell
F:\worksp\ruby>ruby class-initialize.rb
Parent is created

F:\worksp\ruby>
```

//更多请阅读：https://www.yiibai.com/ruby/oops.html#

## 1.3 与类相关的一些基本方法

- `instance_methods(false)`：列出类(class)内部的方法，一般为false，表示仅列举出定义了的方法。即使方法（函数）为空，也会被列举出来。

```ruby
puts Class.instance_methods(false)
```

- `respond_to?`：调查对象(object)的方法/属性是否可用。一般类会对自身的属性或方法作出外部调用的限制，输出true或false。

```ruby
puts "Ist es möglich anzurufen: " + object.respond_to?("title").to_s
```

- `send`：执行对象(object)相应的方法。

```ruby
if object.respond_to?("show") #判断对象是否存在show方法
   object.send("show")       #执行指定的方法
end
```




## 1.4 外部修改object的属性值

类内的属性（Attribute）默认为私密状态。

```ruby
class Game
    attr_accessor :price, :title #可以被外部调用修改
    def initialize(title = "怪物猎人世界", price = 200)
        @title = title
        @price = price
    end
    def show()
        puts "标题: #{@title}"
        puts "价格: #{@price}"
    end
end
mygame = Game.new() #实例化（ instantiate ）

# to_s用于puts输出
puts "title is " + mygame.respond_to?("title").to_s
puts "price is " + mygame.respond_to?("price").to_s
# 由于均被设置为可以获取，故下面语句不会报错。
mygame.title = "Super Mario World"
mygame.price = 150
mygame.show()
```

## 1.5 静态方法——self

self.Methods只能被类本身（class）而不能被实例（object）调用

```ruby
class Game
    def initialize(id, title, price)
        @id = id
        @title = title
        @price = price
    end

    def showGame
        puts @id + ", " + @title + ", " + @price.to_s
    end

    def self.toStr
        puts "I love this game."
    end
end

zelda = Game.new("zelda", "ゼルダの伝説", 350)
zelda.showGame
#zelda.toStr #去掉注释会报错
# 以下两种调用方式均可。
Game.toStr
Game::toStr
```

# 2 Ruby对象

`Object`类是所有Ruby对象的默认根。 Ruby对象继承自`BasicObject`(它是Ruby中所有类的父类)类，允许创建替代对象层次结构。
对象混合在内核模块中，使得内置的内核功能可以全局访问。

在Ruby中，一切东西都是一个对象。 当创建对象时，它们通过方法进行来执行具体的操作。 因此，一个对象是数据和方法的组合。

要创建一个对象，首先要定义一个类。定义一个类可用于创建多个对象。 使用`new`关键字声明对象。


## 2.1 创建对象

Ruby中的对象是通过调用类的`new`方法来创建的。 它是一种独特的方法，并在Ruby库中预定义。

Ruby对象是类的实例。

**语法**

```ruby
objectName = className.new
```

**示例：**

假设我们有一个名为`Stuent`的类。 现在，创建一个对象`stu`，并使用以下命令，

```ruby
stu = Studen.new("John")
```

完整示例代码 -

```ruby
class Student
  attr_accessor :name, :phone
  def introduction()
    puts "Hi , I'm #{name}!"
  end

def say_hello(name, toname)
  puts "Hello, #{toname}! I'm #{name}"
  end

end

stu = Student.new
stu.name = "Maxsu"
stu.introduction()
stu.say_hello('Katrina', 'Maxsu')
```

将上面代码保存到文件：_student.rb_，执行上面代码，得到以下结果 -

```shell
F:\worksp\ruby>ruby Student.rb
Hi , I'm Maxsu!
Hello, Maxsu! I'm Katrina

F:\worksp\ruby>
```


# 3 Ruby方法

方法是在类的主体内定义的函数。 Ruby中的数据只能通过方法访问。 当调用方法时，Ruby会根据一个跟踪路径来查找。可以使用`ancestors`方法找出方法名称。

## 3.1 定义方法

方法用`def`关键字定义，并以`end`关键字结尾。

定义一个方法：`get_name`，所下示例显示。

```shell
F:\worksp\ruby>irb
irb(main):006:0> def get_name
irb(main):007:1>   puts "My name is Maxsu"
irb(main):008:1> end
=> :get_name
irb(main):009:0> get_name
My name is Maxsu
=> nil
irb(main):010:0>
```

`def`关键字开始方法名称的定义。 然后编写方法的具体实现。 最后一行 `end` 表示该方法定义完成。

## 3.2 实例方法

实例方法也使用`def`关键字定义，只能在类实例中使用。

**示例：**

```ruby
#!/usr/bin/ruby -w   
# file : instance-methods.rb

# define a class   
class Circle   
   # constructor method   
   def initialize(r)   
      @radius = r   
   end   
   # instance method   
   def getArea   
      3.14 * @radius * @radius   
   end   
end   

# create an object   
circle = Circle.new(200)   

# call instance methods   
a = circle.getArea()   
puts "Area of the box is : #{a}"
```

执行上面代码，得到以下结果 -

```shell
F:\worksp\ruby>ruby instance-methods.rb
Area of the box is : 125600.0

F:\worksp\ruby>
```

# 4 Class继承

面向对象的编程必然会涉及到继承的问题。Ruby的继承的基本思路与其他编程语言类似。  
Ruby使用“<”继承：`Subclass < Father_class`

在继承中，使用预定义的类创建新类。新创建的类称为派生类，派生类的类称为基类。 通过继承可以重新使用代码，从而降低程序的复杂性。

Ruby不支持多级继承。而是支持混合型(mixins)。

在Ruby中，`<`字符用于创建一个子类。 语法如下所示：

```ruby
parentClass < subClass
```


```ruby
#继承上一段代码的类
class SteamGame < Game
    def SteamInfo
        puts "G胖说了,STEAM要统一各个平台，完成Game All In One。"
    end
end
SteamGame.toStr
mygame = SteamGame.new("nobunaga-taishi", "信長の野望・大志", 450)
mygame.showGame
mygame.SteamInfo
```


```ruby
#!/usr/bin/ruby   
# file : inheritance.rb
class Parent   

    def initialize   
        puts "Parent class created"   
    end   
end   

class Child < Parent   

   def initialize   
       super   
       puts "Child class created"   
   end   
end   

Parent.new   
Child.new
```

在上面的例子中，创建了两个类：一个是`Base`类，另一个是派生的`Child`类。`super`方法调用`Parent`类的构造函数。

最后的两行实例化了这两个类。

执行上面示例代码，得到以下结果 -
```ruby
F:\worksp\ruby>ruby inheritance.rb
Parent class created
Parent class created
Child class created

F:\worksp\ruby>
```

在输出中，首先创建`Parent`类的对象，派生的`Child`类也调用其父类的构造函数，然后创建`Child`类。

# 5 类的真相
## 5.1 对象有什么

```
class  MyClass
    def my_method
       @v=1
     end
end

obj = MyClass.new
puts obj.class
obj.my_method
obj.instance_variables

puts obj.methods
```

* 实例变量：Ruby中对象的类和它的实例变量没有关系
* 方法:Object#methods 绝大多数对象都从Object类继承了一组方法

>一个对象的实例变量存在于对象本身之中，而一个对象的方法存在于对象自身的类中。

## 5.2 类的真相

**类本身也是对象**
```
puts "HELLO".class
puts String.class

puts Class.instance_methods(false)
```

在Ruby中，可以像操作其他任何对象一样对类进行操作。可在运行时，修改类的相关信息。
```
puts Array.superclass
puts Object.superclass
puts BasicObject.superclass
puts Class.superclass
puts Class.superclass.superclass
```


## 5.3 对象和类的小姐 
* 对象：一组实例变量+一个指向类的引用。对象的方法并不存在于对象本身，而是存在于对象的类中。（这些方法被称为类的实例方法）
* 类：一个对象（Class类的一个实例）+一组实例方法+一个指向超类的引用。Class类是Module类的一个引用，因此类也是一个模块。


## 5.4 模块 和类比较
Class类的超类是Module（模块）=====》每个类都是一个模块

类就是带有三个方法(new,allocate,superclass)的增强模块

代码被包含到别的代码中----->使用模块
某段代码被实例化或被继承----->使用类


类可通过引用访问

```
class Foo
end
foo = Foo.new
myFoo = Foo
foo2= myFoo.new
```
myFoo是变量，Foo是常量 类是对象，类名是常量


# 6 例子

## 6.1 classfact.rb 

```ruby
#!/usr/bin/ruby
# -*- coding: UTF-8 -*-

class  MyClass
    def my_method
       @v=1
     end
end

obj = MyClass.new
puts obj.class
obj.my_method
obj.instance_variables

puts obj.methods.grep(/my/)

puts "HELLO".class
puts String.class
puts "Class类的实例方法:"
puts Class.instance_methods(false)

puts Array.superclass
puts Object.superclass
puts BasicObject.superclass.class.name
puts Class.superclass
puts Class.superclass.superclass

class Foo
    def initialize
    	puts "initialize"
    end
end
foo = Foo.new
myFoo = Foo
foo2= myFoo.new

MyConstant = "root level"
module MyModule
	MyConstant = "outer"
	class MyFoo
		MyConstant = "inner"
		module InnerModule
			puts Module.nesting
		end
	end
end

puts MyModule::MyConstant
puts MyModule::MyFoo::MyConstant
puts ::MyConstant

# puts 'Module:'
# puts Module.constants
# puts 'Instance:'
# puts MyModule.constants
puts Module.nesting


puts "----------"
puts Object.class
puts Module.class.superclass
puts Module.superclass
puts Module.class
puts Class.class

```



## 6.2 greeting.rb

```ruby
#!/usr/bin/ruby
# -*- coding: UTF-8 -*-
class Greeting
	def initialize(text)
		@text = text
	end

	def welcome
		@text
	end
end

object = Greeting.new("Hi")

#通过方法调用得知（询问）object的类
puts object.class

#询问类的实例方法 false表示不要继承来的方法
puts object.class.instance_methods(false)

#询问实例变量
puts object.instance_variables

```



## 6.3 lookup.rb

```ruby
#!/usr/bin/ruby
# -*- coding: UTF-8 -*-

class MyClass
	def my_method
		'my_method'
	end
end

class MySubClass < MyClass
end

obj = MySubClass.new
puts obj.my_method

puts "MySubClass的祖先链:"
puts MySubClass.ancestors

module MyModule
	def method_in_mymodule
		puts "method in MyModule"
	end
end

#使用include方法包含模块
class TestClass
	include MyModule
end
class D <TestClass
end

puts "D的祖先链(include)："
puts D.ancestors

#使用prepend方法包含模块(Ruby2.0开始)
class TestPrependClass
	prepend MyModule
end
class E < TestPrependClass
end

puts "E的祖先链(prepend)："
puts E.ancestors

puts "Object类的祖先链"
puts Object.ancestors

puts "Kernel中以pr开头的私有实例方法"
puts Kernel.private_instance_methods.grep(/^pr/)


```


## 6.4 openclass.rb

```ruby
#!/usr/bin/ruby
# -*- coding: UTF-8 -*-

3.times do
	class Foo
		puts "Hello World"
	end
end

# 并没有定义三个同名的类

#第一次定义D的时候 D类并不存在
#Ruby开始定义这个类 并定义x方法
class D
	def initialize
		puts "init in first"
	end
	def x
		puts 'x'
	end
end

#D类已经存在，Ruby不再定义
#只是重新打开这个已经存在的类，
#并定义y方法
class D
	def initialize
		puts "init in second"
	end
	def y
		puts 'y'
	end
end

d = D.new
d.x
d.y

```


## 6.5 ##
```ruby
#!/usr/bin/ruby
# -*- coding: UTF-8 -*-
require './fileRead'

fileRead = FileRead.new(__FILE__)
if ARGV.length == 0
elsif ARGV[0] == 'true'|| ARGV[0]=='TRUE'||ARGV[0]=='True'
	fileRead.filtprint
elsif ARGV[0] == 'false'|| ARGV[0]=='FALSE'||ARGV[0]=='False'
	fileRead.nofiltprint
else
end
# Ruby是一种面向对象的编程语言 
# 数据封装 数据抽象 多态 继承



# 定义类，关键字class 类名的首字母大写
# end终止一个类
class Car
end



# Ruby类中的变量
# 四种类型
# 局部变量 方法中定义 以小写字母或_开始
# 实例变量 可跨任何特定的实例或对象的方法中使用 在变量名前加@符号
# 类变量 可跨不同的对象使用 属于类 是类的一个属性 在变量名前加@@符号
# 全局变量 可跨类使用 在变量名前加$符号

class Person
	@@sum_of_person = 0#类变量
	def initialize(name) 
		@@sum_of_person=@@sum_of_person+1
		@name=name #实例变量
	end
	def print_name #成员方法
		puts "name:#@name"
	end
end


# 使用new方法来创建对象，new方法在Ruby库中预定义，属于类方法
person1 = Person.new("John")
person2 = Person.new("Kobe")

person1.print_name
person2.print_name

puts Person.class_variable_get:@@sum_of_person
```